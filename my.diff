diff --git a/lib/Target/Coffee/CoffeeFrameLowering.cpp b/lib/Target/Coffee/CoffeeFrameLowering.cpp
index 9db0d8c..f74e6aa 100644
--- a/lib/Target/Coffee/CoffeeFrameLowering.cpp
+++ b/lib/Target/Coffee/CoffeeFrameLowering.cpp
@@ -33,14 +33,19 @@ using namespace llvm;
 /// or if frame pointer elimination is disabled.
 bool CoffeeFrameLowering::hasFP(const MachineFunction &MF) const {
 
-    const TargetRegisterInfo *RegInfo = MF.getTarget().getRegisterInfo();
+    /*const TargetRegisterInfo *RegInfo = MF.getTarget().getRegisterInfo();
     const MachineFrameInfo *MFI = MF.getFrameInfo();
     // Always eliminate non-leaf frame pointers.
     return ((MF.getTarget().Options.DisableFramePointerElim(MF) &&
              MFI->hasCalls()) ||
             RegInfo->needsStackRealignment(MF) ||
             MFI->hasVarSizedObjects() ||
-            MFI->isFrameAddressTaken());
+            MFI->isFrameAddressTaken());*/
+
+
+    const MachineFrameInfo *MFI = MF.getFrameInfo();
+    return MF.getTarget().Options.DisableFramePointerElim(MF) ||
+        MFI->hasVarSizedObjects() || MFI->isFrameAddressTaken();
 
 }
 
@@ -284,7 +289,7 @@ CoffeeFrameLowering::processFunctionBeforeCalleeSavedScan(MachineFunction &MF,
     // to take advantage the eliminateFrameIndex machinery. This also ensures it
     // is spilled in the order specified by getCalleeSavedRegs() to make it easier
     // to combine multiple loads / stores.
-    bool CanEliminateFrame = true;
+    /*bool CanEliminateFrame = true;
     bool CS1Spilled = false;
     bool LRSpilled = false;
     unsigned NumGPRSpills = 0;
@@ -364,7 +369,29 @@ CoffeeFrameLowering::processFunctionBeforeCalleeSavedScan(MachineFunction &MF,
     bool ExtraCSSpill = false;
     if (BigStack || !CanEliminateFrame || RegInfo->cannotEliminateFrame(MF)) {
         AFI->setHasStackFrame(true);
-      }
+      }*/
+
+    MachineRegisterInfo& MRI = MF.getRegInfo();
+    unsigned FP = Coffee::FP;
+
+    // FIXME: remove this code if register allocator can correctly mark
+    //        $fp and $ra used or unused.
+
+    // Mark $fp and $ra as used or unused.
+    if (hasFP(MF))
+      MRI.setPhysRegUsed(FP);
+
+    // The register allocator might determine $ra is used after seeing
+    // instruction "jr $ra", but we do not want PrologEpilogInserter to insert
+    // instructions to save/restore $ra unless there is a function call.
+    // To correct this, $ra is explicitly marked unused if there is no
+    // function call.
+    if (MF.getFrameInfo()->hasCalls())
+      MRI.setPhysRegUsed(Coffee::LR);
+    else {
+      MRI.setPhysRegUnused(Coffee::LR);
+    }
+
   }
 
 void CoffeeFrameLowering::processFunctionBeforeFrameFinalized(MachineFunction &MF)
diff --git a/lib/Target/Coffee/CoffeeISelDAGToDAG.cpp b/lib/Target/Coffee/CoffeeISelDAGToDAG.cpp
index ab3f081..2462b75 100644
--- a/lib/Target/Coffee/CoffeeISelDAGToDAG.cpp
+++ b/lib/Target/Coffee/CoffeeISelDAGToDAG.cpp
@@ -50,6 +50,8 @@ public:
     //Complex Pattern selectors
     bool SelectAddr(SDNode *Parent, SDValue N, SDValue &Base, SDValue &Offset);
 
+    SDNode* SelectMULT(SDNode *N, DebugLoc dl);
+
     /// getI32Imm - Return a target constant of type i32 with the specified
     /// value.
     inline SDValue getI32Imm(unsigned Imm) {
@@ -114,7 +116,11 @@ bool CoffeeDAGToDAGISel::SelectAddr(SDNode *Parent, SDValue Addr, SDValue &Base,
     // Operand is a result from an ADD.
     if (Addr.getOpcode() == ISD::ADD) {
 
-        llvm_unreachable("coffee: we need to recheck");
+        //guoqing: no need to do anything here,
+        // it was just a pesudo instr for mips
+        // we don't need it in coffee
+
+        //llvm_unreachable("coffee: we need to recheck");
       // When loading from constant pools, load the lower address part in
       // the instruction itself. Example, instead of:
       //  lui $2, %hi($CPI1_0)
@@ -151,8 +157,11 @@ SDNode* CoffeeDAGToDAGISel::Select(SDNode *N) {
     if (N->isMachineOpcode())
       return NULL;   // Already selected.
 
+    EVT NodeTy = N->getValueType(0);
+
     switch (N->getOpcode()) {
     default: break;
+
     case COFFEEISD::BRCOND: {
 
 
@@ -168,7 +177,6 @@ SDNode* CoffeeDAGToDAGISel::Select(SDNode *N) {
         // Emits: (t2Bcc:void (bb:Other):$dst, (imm:i32):$cc)
         // Pattern complexity = 6  cost = 1  size = 0
 
-
         SDValue Chain = N->getOperand(0);
         SDValue N1 = N->getOperand(1);
         SDValue N2 = N->getOperand(2);
@@ -220,10 +228,69 @@ SDNode* CoffeeDAGToDAGISel::Select(SDNode *N) {
         return NULL;
 
     }
+
+        // guoqing: we don't do anything to ISD::MUL as the muls muli instruction
+        // will put the lo to destination register automatically
+
+        // guoqing: these are meant for handling hi part
+        case ISD::MULHS:
+        case ISD::MULHU: {
+          if (NodeTy == MVT::i32)
+            return SelectMULT(N, dl);
+          else
+              llvm_unreachable("coffee: nodetype for mulhs is not i32");
+
+
+        }
 }
 
     return SelectCode(N);
 }
+
+/// Select multiply instructions.
+SDNode*
+CoffeeDAGToDAGISel::SelectMULT(SDNode *N, DebugLoc dl) {
+
+    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N->getOperand(1));
+
+    unsigned Opc = 0;
+    if (CN) {
+    // signed 15 bit imm
+
+        bool test = isInt<15>(CN->getSExtValue());
+        bool test1 = isInt<32>(CN->getSExtValue());
+
+        if (isInt<15>(CN->getSExtValue()))
+            Opc = Coffee::MULTI;
+        else
+           Opc = Coffee::MULTR;
+    } else {
+      // register
+        Opc = Coffee::MULTR;
+    }
+
+    if (Opc == 0 ) llvm_unreachable("coffee: selectMULT");
+
+  SDNode *Mul = CurDAG->getMachineNode(Opc, dl, MVT::i32, MVT::Glue, N->getOperand(0),
+    N->getOperand(1));
+
+  // take the second output which is glue
+  SDValue glue = SDValue(Mul, 1);
+
+
+  /* def MULHI   : InstCoffee<(outs GPRC:$rd), (ins), "mulhi\t$rd", [], IIAlu, FrmJ> {
+    }*/
+  // this MULHI instruction is meant for telling which register is used to save the upper half of the
+  // mulitplication result so no inputs are needed here.
+  // but we need to take the glue output from MULTI/MULTR so that it will guarantee the MULHI will appear
+  // right after them.
+
+  return CurDAG->getMachineNode(Coffee::MULHI, dl,
+                                MVT::i32, glue);
+
+
+}
+
 /// createCoffeeISelDag - This pass converts a legalized DAG into a
 /// Coffee-specific DAG, ready for instruction scheduling.
 ///
diff --git a/lib/Target/Coffee/CoffeeISelLowering.cpp b/lib/Target/Coffee/CoffeeISelLowering.cpp
index 5c9e0d4..77387d9 100644
--- a/lib/Target/Coffee/CoffeeISelLowering.cpp
+++ b/lib/Target/Coffee/CoffeeISelLowering.cpp
@@ -91,8 +91,6 @@ CoffeeTargetLowering::CoffeeTargetLowering(CoffeeTargetMachine &TM)
 
     setOperationAction(ISD::BR_JT,     MVT::Other, Custom);
 
-
-
     // Mips Custom Operations
     setOperationAction(ISD::GlobalAddress,      MVT::i32,   Custom);
     setOperationAction(ISD::BlockAddress,       MVT::i32,   Custom);
@@ -868,7 +866,7 @@ SDValue CoffeeTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) cons
   case ISD::FRAMEADDR:
   case ISD::BRCOND:
   case ISD::ConstantPool:
-  case ISD::DYNAMIC_STACKALLOC:
+
   case ISD::BlockAddress:
   case ISD::GlobalTLSAddress:
   case ISD::JumpTable:
@@ -880,11 +878,59 @@ SDValue CoffeeTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) cons
   case ISD::MEMBARRIER:
   case ISD::ATOMIC_FENCE:
       return Op;
+  //case ISD::MUL: return LowerMUL(Op, DAG);
   case ISD::GlobalAddress: return LowerGlobalAddress(Op, DAG);
+  case ISD::DYNAMIC_STACKALLOC: return LowerDYNAMIC_STACKALLOC(Op, DAG);
   case ISD::BR_CC: return LowerBR_CC(Op, DAG);
   }
 }
 
+SDValue CoffeeTargetLowering::LowerMUL(SDValue Op, SelectionDAG &DAG) const
+{
+
+//guoqing: this might need to be lowered when we need to support 64 bit output
+    // leave it empty for now
+}
+
+
+SDValue CoffeeTargetLowering::
+LowerDYNAMIC_STACKALLOC(SDValue Op, SelectionDAG &DAG) const
+{
+  MachineFunction &MF = DAG.getMachineFunction();
+  CoffeeFunctionInfo *CoffeeFI = MF.getInfo<CoffeeFunctionInfo>();
+  unsigned SP = Coffee::SP;
+
+  assert(getTargetMachine().getFrameLowering()->getStackAlignment() >=
+         cast<ConstantSDNode>(Op.getOperand(2).getNode())->getZExtValue() &&
+         "Cannot lower if the alignment of the allocated space is larger than \
+          that of the stack.");
+
+  SDValue Chain = Op.getOperand(0);
+  SDValue Size = Op.getOperand(1);
+  DebugLoc dl = Op.getDebugLoc();
+
+  // Get a reference from Coffee stack pointer
+  SDValue StackPointer = DAG.getCopyFromReg(Chain, dl, SP, getPointerTy());
+
+  // Subtract the dynamic size from the actual stack size to
+  // obtain the new stack size.
+  SDValue Sub = DAG.getNode(ISD::SUB, dl, getPointerTy(), StackPointer, Size);
+
+  // The Sub result contains the new stack start address, so it
+  // must be placed in the stack pointer register.
+  Chain = DAG.getCopyToReg(StackPointer.getValue(1), dl, SP, Sub, SDValue());
+
+  // This node always has two return values: a new stack pointer
+  // value and a chain
+  SDVTList VTLs = DAG.getVTList(getPointerTy(), MVT::Other);
+  SDValue Ptr = DAG.getFrameIndex(CoffeeFI->getDynAllocFI(), getPointerTy());
+  SDValue Ops[] = { Chain, Ptr, Chain.getValue(1) };
+
+  return DAG.getNode(COFFEEISD::DynAlloc, dl, VTLs, Ops, 3);
+}
+
+
+
 SDValue CoffeeTargetLowering::LowerGlobalAddress(SDValue Op,
                                                  SelectionDAG &DAG) const {
     // FIXME there isn't actually debug info here
diff --git a/lib/Target/Coffee/CoffeeISelLowering.h b/lib/Target/Coffee/CoffeeISelLowering.h
index fcae232..0a6f146 100644
--- a/lib/Target/Coffee/CoffeeISelLowering.h
+++ b/lib/Target/Coffee/CoffeeISelLowering.h
@@ -35,7 +35,10 @@ enum NodeType {
     BRCOND,
     CMP,
     Hi,
-    Lo
+    Lo,
+    DynAlloc,
+    MUL,
+    MUL_64
 };
 }
 
@@ -105,6 +108,10 @@ public:
     bool isLegalICmpImmediate(int64_t Imm) const;
 
     virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;
+
+    SDValue LowerDYNAMIC_STACKALLOC(SDValue Op, SelectionDAG &DAG) const;
+
+    SDValue LowerMUL(SDValue Op, SelectionDAG &DAG) const;
 };
 }
 
diff --git a/lib/Target/Coffee/CoffeeInstrInfo.td b/lib/Target/Coffee/CoffeeInstrInfo.td
index cc9604b..8479b89 100644
--- a/lib/Target/Coffee/CoffeeInstrInfo.td
+++ b/lib/Target/Coffee/CoffeeInstrInfo.td
@@ -20,6 +20,14 @@ def SDT_COFFEECallSeqStart : SDCallSeqStart<[ SDTCisVT<0, i32> ]>;
 def SDT_COFFEECallSeqEnd   : SDCallSeqEnd<[ SDTCisVT<0, i32>, SDTCisVT<1, i32> ]>;
 def SDT_COFFEECmp     : SDTypeProfile<0, 2, [SDTCisSameAs<0, 1>]>;
 def SDT_COFFEERet          : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
+def SDT_COFFEEDynAlloc    : SDTypeProfile<1, 1, [SDTCisVT<0, iPTR>,
+                                               SDTCisSameAs<0, 1>]>;
+
+
+def SDT_MUL     : SDTypeProfile<1, 2, [SDTCisSameAs<0, 1>]>;
+
+def SDT_MUL_64     : SDTypeProfile<0, 1, []>;
+
 //def SDT_COFFEEBrcond  : SDTypeProfile<0, 2,
 //                                   [SDTCisVT<0, OtherVT>, SDTCisVT<1, i32>]>;
 
@@ -40,8 +48,9 @@ def COFFEEcall          : SDNode<"COFFEEISD::CALL", SDT_COFFEEcall,
 def COFFEEret         : SDNode<"COFFEEISD::RET", SDT_COFFEERet,
                               [SDNPHasChain, SDNPOptInGlue]>;
 
-
-
+//guoqing: this might be needed when we need to sup
+def MUL              : SDNode<"COFFEEISD::MUL", SDT_MUL, [SDNPOutGlue]>;
+def MUL_64           : SDNode<"COFFEEISD::MUL_64", SDT_MUL_64, [SDNPInGlue]>;
 
 //def COFFEEbrcond        : SDNode<"COFFEEISD::BRCOND", SDT_COFFEEBrcond,
 //                              [SDNPHasChain, SDNPInGlue]>;
@@ -52,6 +61,10 @@ def COFFEEcmp           : SDNode<"COFFEEISD::CMP", SDT_COFFEECmp,
 def COFFEEHi    : SDNode<"COFFEEISD::Hi", SDTIntUnaryOp>;
 def COFFEELo    : SDNode<"COFFEEISD::Lo", SDTIntBinOp>;
 
+// Pointer to dynamically allocated stack area.
+def COFFEEDynAlloc  : SDNode<"COFFEEISD::DynAlloc", SDT_COFFEEDynAlloc,
+                           [SDNPHasChain, SDNPInGlue]>;
+
 
 def immSExt16  : PatLeaf<(imm), [{ return isInt<16>(N->getSExtValue()); }]>;
 
@@ -296,9 +309,9 @@ def BNE     :  CBranch<0b000000, "bne", setne>;
 let isCompare = 1, Defs = [CR0] in {
 multiclass I_cmp<PatFrag opnode> {
   def ri : InstCoffee<(outs), (ins GPRC:$Rn, simm16:$imm),
-               "cmpi\t$Rn, $imm", [(opnode GPRC:$Rn, imm:$imm)], IIAlu, FrmI> {}
+               "cmpi\t$Rn,\t$imm", [(opnode GPRC:$Rn, imm:$imm)], IIAlu, FrmI> {}
   def rr : InstCoffee<(outs), (ins GPRC:$Rn, GPRC:$Rm),
-               "cmp\t$Rn, $Rm", [(opnode GPRC:$Rn, GPRC:$Rm)], IIAlu, FrmI> {}
+               "cmp\t$Rn,\t$Rm", [(opnode GPRC:$Rn, GPRC:$Rm)], IIAlu, FrmI> {}
 }
 }
 
@@ -414,16 +427,40 @@ class StoreM<bits<6> op, string instr_asm, PatFrag OpNode, RegisterClass RC,
 class ArithLogicI<bits<6> op, string instr_asm, SDNode OpNode,
                   Operand Od, PatLeaf imm_type, RegisterClass RC> :
   FI<op, (outs RC:$rt), (ins RC:$rs, Od:$imm16),
-     !strconcat(instr_asm, "\t$rt, $rs, $imm16"),
+     !strconcat(instr_asm, "\t$rt,\t$rs,\t$imm16"),
      [(set RC:$rt, (OpNode RC:$rs, imm_type:$imm16))], IIAlu> {
   let isReMaterializable = 1;
 }
 
+class ArithOverflowI<bits<6> op, string instr_asm, SDNode OpNode,
+                     Operand Od, PatLeaf imm_type, RegisterClass RC> :
+  FI<op, (outs RC:$rt), (ins RC:$rs, Od:$imm16),
+     !strconcat(instr_asm, "\t$rt, $rs, $imm16"), [], IIAlu>;
+
+
+class ArithLogicR<bits<6> op, string instr_asm, SDNode OpNode,
+                  InstrItinClass itin, RegisterClass RC, bit isComm = 0>:
+  FR<op, (outs RC:$rd), (ins RC:$rs, RC:$rt),
+     !strconcat(instr_asm, "\t$rd,\t$rs,\t$rt"),
+     [(set RC:$rd, (OpNode RC:$rs, RC:$rt))], itin> {
+  /*let shamt = 0;
+  let isCommutable = isComm;
+  let isReMaterializable = 1;*/
+}
+
+class ArithOverflowR<bits<6> op, string instr_asm,
+                    InstrItinClass itin, RegisterClass RC, bit isComm = 0>:
+  FR<op, (outs RC:$rd), (ins RC:$rs, RC:$rt),
+     !strconcat(instr_asm, "\t$rd,\t$rs,\t$rt"), [], itin> {
+ /* let shamt = 0;
+  let isCommutable = isComm;*/
+}
+
 
 // Load Upper Imediate
 class LoadUpper<bits<6> op, string instr_asm, RegisterClass RC, Operand Imm>:
   FI<op, (outs RC:$rt), (ins Imm:$imm16),
-     !strconcat(instr_asm, "\t$rt, $imm16"), [], IIAlu> {
+     !strconcat(instr_asm, "\t$rt,\t$imm16"), [], IIAlu> {
 
   let neverHasSideEffects = 1;
   let isReMaterializable = 1;
@@ -432,10 +469,22 @@ class LoadUpper<bits<6> op, string instr_asm, RegisterClass RC, Operand Imm>:
 
 def immZExt16  : PatLeaf<(imm), [{return (uint32_t)N->getZExtValue() == (unsigned short)N->getZExtValue();}], LO16>;
 
-// Arithmetic Instruction
+// Arithmetic Instruction (imm)
+def ADDiu   : ArithLogicI<0b000000, "addiu", add, simm16, immSExt16, GPRC>;
+def ADDi    : ArithOverflowI<0b000000, "addi", add, simm16, immSExt16, GPRC>;
 def ORi     : ArithLogicI<0b000000, "ori", or, uimm16, immZExt16, GPRC>;
 def LUi     : LoadUpper<0b000000, "lui", GPRC, uimm16>;
 
+// Arithmetic Instruction (reg)
+def ADDu    : ArithLogicR<0b000000, "addu", add, IIAlu, GPRC>;
+def SUBu    : ArithLogicR<0b000000, "subu", sub, IIAlu, GPRC>;
+def ADD     : ArithOverflowR<0b000000, "add", IIAlu, GPRC>;
+def SUB     : ArithOverflowR<0b000000, "sub", IIAlu, GPRC>;
+
+def AND     : ArithLogicR<0b000000, "and", and, IIAlu, GPRC>;
+def OR      : ArithLogicR<0b000000, "or",  or, IIAlu, GPRC>;
+def XOR     : ArithLogicR<0b000000, "xor", xor, IIAlu, GPRC>;
+
 /// Load and Store Instructions
 ///  aligned
 
@@ -555,3 +604,64 @@ def : Pat<(COFFEELo GPRC:$src, tglobaladdr:$in), (ORi GPRC:$src, tglobaladdr:$in
 
 
 
+/// Shift Instructions
+def immZExt6 : ImmLeaf<i32, [{return Imm == (Imm & 0x3f);}]>;
+def shamt       : Operand<i32>;
+
+class shift_imm<bits<6> opcode, string instr_asm,
+                       SDNode OpNode, PatFrag PF, Operand ImmOpnd,
+                       RegisterClass RC>:
+  FR<opcode, (outs RC:$rd), (ins RC:$rt, ImmOpnd:$shamt),
+     !strconcat(instr_asm, "\t$rd,\t$rt,\t$shamt"),
+     [(set RC:$rd, (OpNode RC:$rt, PF:$shamt))], IIAlu> {
+
+}
+
+// 32-bit shift instructions.
+class shift_imm32<bits<6> opcode, string instr_asm,
+                         SDNode OpNode>:
+  shift_imm<opcode, instr_asm, OpNode, immZExt6, shamt, GPRC>;
+
+class shift_reg<bits<6> opcode, string instr_asm,
+                       SDNode OpNode, RegisterClass RC>:
+  FR<opcode, (outs RC:$rd), (ins GPRC:$rs, RC:$rt),
+     !strconcat(instr_asm, "\t$rd,\t$rt,\t$rs"),
+     [(set RC:$rd, (OpNode RC:$rt, GPRC:$rs))], IIAlu> {
+
+}
+
+
+def SLLI     : shift_imm32<0b000000, "slli", shl>;
+def SRLI     : shift_imm32<0b000000, "srli", srl>;
+def SRAI     : shift_imm32<0b000000, "srai", sra>;
+def SLLR    : shift_reg<0b000000, "sll", shl, GPRC>;
+def SRLR    : shift_reg<0b000000, "srl", srl, GPRC>;
+def SRAR    : shift_reg<0b000000, "sra", sra, GPRC>;
+
+
+// select COFFEEDynAlloc
+def : Pat<(COFFEEDynAlloc addr:$f), (DynAlloc addr:$f)>;
+
+def MULR   : ArithLogicR<0b000000, "muls", mul, IIImul, GPRC>;
+def MULI   : ArithLogicI<0b000000, "muli", mul, simm16, immSExt16, GPRC>;
+
+def MULTR   : ArithLogicR<0b000000, "muls", MUL, IIImul, GPRC>;
+def MULTI   : ArithLogicI<0b000000, "muli", MUL, simm16, immSExt16, GPRC>;
+
+// no pattern
+
+/*class HI<string instr_asm, RegisterClass RC,
+                   list<Register> UseRegs>:
+  FR<0b000000, func, (outs RC:$rd), (ins),
+     !strconcat(instr_asm, "\t$rd"), [], IIHiLo> {
+  let rs = 0;
+  let rt = 0;
+  let shamt = 0;
+  let Uses = UseRegs;
+  let neverHasSideEffects = 1;
+}*/
+
+def MULHI   : InstCoffee<(outs GPRC:$rd), (ins), "mulhi\t$rd", [], IIAlu, FrmJ> {
+  let Inst{31-26} = 0b111010;
+  let Inst{15-10} = 0b111010;
+  }
